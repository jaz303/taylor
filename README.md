# taylor

`taylor` is an __experimental__ package manager and build tool for Apple's Swift programming language, developed to explore the possibilities for growing a module ecosystem around the language. It borrows elements from similar tools such as `npm`, `lein` and `bundler`.

With `taylor`'s command line interface you can:

  * Create projects
  * Install 3rd party module packages directly from Git repositories
  * Build applications with a single command

Read on for installation instructions and a tutorial project. Please [follow me on Twitter](http://twitter.com/jaz303) to keep up with development progress.

## Contents

  - [Overview](#overview)
  - [Installation](#installation)
  - [Terminology](#terminology)
  - [Tutorial](#tutorial)
  - [Technical Details](#technical)
  - [Command Reference](#reference)
  - [Current Limitations](#limitations)

## <a name='overview'></a>Overview

`taylor` rides on top of `make(1)` and other CLI tools; it is not an Xcode project generator.

This preview version of `taylor` is written in Javascript; a native Swift implementation is a worthwhile long-term goal but no work in this direction will begin until the final versions of the Swift compiler and language specification have been released. In light of this, Javascript should be considered a mere implementation detail, not a core part of `taylor`'s specification.

## <a name='installation'></a>Installation

### Prerequisites

  1. Install node.js. Any recent version should do.
  2. `taylor` assumes that Xcode6 Beta is installed in the default location (`/Applications/Xcode6-Beta.app`). If this is not the case, define the environment variable `TAYLOR_SWIFT_TOOLCHAIN` to point to the `Contents/Developer/Toolchains/XcodeDefault.xctoolchain` subdirectory within wherever Xcode is installed.

All set? Let's go (depending on your configuration the following command may require `sudo`):

    $ npm install -g taylor

Now check that `taylor` was installed successfully:

    $ taylor -v
    0.0.2

## <a name='terminology'></a>Terminology

`taylor`'s installable units are called _packages_. A package defines one or more _targets_, each of a given _target type_. Two target types are currently defined: _module target_, which builds a Swift module that can be imported by other packages, and _app target_, which builds an executable binary, possibly importing other packages.

For brevity's sake, the terms _app_ and _module_ may be used to refer to packages with targets of type app and module, respectively.

## <a name='tutorial'></a>Tutorial

    $ taylor create TaylorTest
    
    $ cd TaylorTest
    
    $ find .

    .
    ./.gitignore
    ./src
    ./src/main.swift
    ./swiftpkg.json

    $ cat swiftpkg.json

```json
{
    "name": "TaylorTest",
    "targets": {
        "app": {
            "type": "app"
        }
    }
}
```

    $ cat src/main.swift

```swift
func Main() -> Int {
    println("Hello world!");
    return 0;
}
```

    $ taylor build

    $ ls -l build/app
    total 88
    -rwxr-xr-x+ 1 jason  staff  44200 22 Jun 11:36 app
    drwxr-xr-x+ 5 jason  staff    170 22 Jun 11:36 lib
    drwxr-xr-x+ 6 jason  staff    204 22 Jun 11:35 module
    
    $ taylor run
    Hello world!

    $ taylor install gh:jaz303/JFTestAdditive
    $ taylor install gh:jaz303/JFTestMultiplicative
    
    $ ls -l modules
    total 0
    drwxr-xr-x  7 jason  staff  238 22 Jun 11:35 JFTestAdditive
    drwxr-xr-x  7 jason  staff  238 22 Jun 11:35 JFTestMultiplicative

    $ vim src/math.swift

```swift
import JFTestAdditive
import JFTestMultiplicative

func DoMath() -> Int {
    return add(15, multiply(30, 2));
}
```

    $ vim src/main.swift

```swift
func Main() -> Int {
    println(DoMath());
    return 0;
}
```

    $ taylor build
    $ taylor run

```
75
```

## <a name='technical'></a>Technical Details

## <a name='reference'></a>Command Reference

#### `taylor create-app <package>`

Create a new skeleton package named `package` with an initial build target of type `app` in the current directory.

#### `taylor create-module <package>`

Create a new skeleton module named `package` with an initial build target of type `module`.

If this command is run in the context of an existing package the new module is created inside the package's `modules` directory. Otherwise, the new module is created in the current directory.

#### `taylor install <module>`

Installs `module` in the `modules` directory of the current package.

For now, `module` must be the URL of a `git` repository although shortcuts exist for installation from Github. The following are all equivalent:

    $ taylor install git@github.com:jaz303/JFTestAdditive.git
    $ taylor install github:jaz303/JFTestAdditive
    $ taylor install gh:jaz303/JFTestAdditive

#### `taylor build [<target>]`

Builds the given target. If `target` is unspecified, all targets will be built.

#### `taylor run [<target>]`

Run the executable generated by `target`; this must be an `app` target.

If unspecified, `target` will default to the package's first available `app` target.

#### `taylor clean`

Delete all build products for the current package. Does not remove supporting Makefiles or any other files created by `taylor regen`.

#### `taylor zap`

Recursively delete all build products, Makefiles and any other generated files, including those contained within installed modules. Use this command to force a fresh build of your entire project tree.

Be warned, this command is somewhat indiscriminate and will delete any `build` directory it encounters, regardless of whether or not it was created by Taylor.

#### `taylor make <target>`

Low level command; run an explicit `make` rule inside Taylor's environment.

#### `taylor regen`

Force regeneration of the current package's Makefile and any other supporting files required by the build process.

#### `taylor invalidate`

Delete the current package's Makefile and any other supporting files required by the build process.

#### `taylor config`

Dump all of Taylor's effective configuration variables to the console.

#### `taylor env`

Dump Taylor's entire environment to the console.

## <a name='limitations'></a>Current Limitations

`taylor` is an experimental tool and currently offers only the minimum functionality to enable module sharing between authors. It currently lacks:

  1. Automatic dependency resolution/installation!
  2. Central package registry
  3. Build profiles e.g. "debug", "release"
  4. Allow targets to explicit state their dependent source files
  5. Invoke REPL
  6. Test running
  7. Linking against external (C) libraries
  
Of these, 1 &amp; 2 are non-trivial, although tools like `bundler` and `npm` have already contributed a lot of work in this space which `taylor` should be able to draw upon. It is expected that tackling the other shortcomings on the list will be straightforward.

## Copyright &amp; License

&copy; 2014 Jason Frame [ [@jaz303](http://twitter.com/jaz303) / [jason@onehackoranother.com](mailto:jason@onehackoranother.com) ]

Released under the ISC license.